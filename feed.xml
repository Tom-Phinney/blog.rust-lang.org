<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Team.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2019-05-23T20:28:47Z</updated>

    
    <entry>
        <title>Announcing Rust 1.35.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/05/23/Rust-1.35.0.html" type="text/html" title="Announcing Rust 1.35.0" />
        <published>2019-05-23T00:00:00Z</published>
        <updated>2019-05-23T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/05/23/Rust-1.35.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/05/23/Rust-1.35.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.35.0. Rust is a
programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust 1.35.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on our website,
and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1350-2019-05-23&quot;&gt;detailed release notes for 1.35.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.35.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.35.0-stable&quot;&gt;&lt;/a&gt;What's in 1.35.0 stable&lt;/h2&gt;
&lt;p&gt;The highlight of this release is the implementation of the &lt;code&gt;FnOnce&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;,
and &lt;code&gt;Fn&lt;/code&gt; closure traits for &lt;code&gt;Box&amp;lt;dyn FnOnce&amp;gt;&lt;/code&gt;, &lt;code&gt;Box&amp;lt;dyn FnMut&amp;gt;&lt;/code&gt;, and &lt;code&gt;Box&amp;lt;dyn Fn&amp;gt;&lt;/code&gt; respectively.
Additionally, closures may now be coerced to unsafe function pointers.
The &lt;code&gt;dbg!&lt;/code&gt; macro introduced in &lt;a href=&quot;https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html#the-dbg-macro&quot;&gt;Rust 1.32.0&lt;/a&gt; can now also be called without arguments.
Moreover, there were a number of standard library stabilizations.
Read on for a few highlights, or see the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1350-2019-05-23&quot;&gt;detailed release notes&lt;/a&gt; for additional information.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#fn-closure-traits-implemented-for-box&lt;dyn-fn*&gt;&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;fn-closure-traits-implemented-for-box&lt;dyn-fn*&gt;&quot;&gt;&lt;/a&gt;&lt;code&gt;Fn*&lt;/code&gt; closure traits implemented for &lt;code&gt;Box&amp;lt;dyn Fn*&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;In Rust 1.35.0, the &lt;code&gt;FnOnce&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, and the &lt;code&gt;Fn&lt;/code&gt; traits &lt;a href=&quot;https://github.com/rust-lang/rust/pull/55431&quot;&gt;are now implemented&lt;/a&gt; for &lt;code&gt;Box&amp;lt;dyn FnOnce&amp;gt;&lt;/code&gt;,
&lt;code&gt;Box&amp;lt;dyn FnMut&amp;gt;&lt;/code&gt;, and &lt;code&gt;Box&amp;lt;dyn Fn&amp;gt;&lt;/code&gt; respectively.&lt;/p&gt;
&lt;p&gt;Previously, if you wanted to call the function stored in a boxed closure, you had to use &lt;a href=&quot;https://doc.rust-lang.org/1.34.0/std/boxed/trait.FnBox.html&quot;&gt;&lt;code&gt;FnBox&lt;/code&gt;&lt;/a&gt;.
This was because instances of &lt;code&gt;Box&amp;lt;dyn FnOnce&amp;gt;&lt;/code&gt; and friends did not implement the respective &lt;code&gt;Fn*&lt;/code&gt; traits.
This also meant that it was not possible to pass boxed functions to code expecting an implementor of a &lt;code&gt;Fn&lt;/code&gt; trait,
and you had to create temporary closures to pass them down.&lt;/p&gt;
&lt;p&gt;This was ultimately due to a limitation in the compiler's ability to reason about such implementations,
which has since been fixed with the introduction of &lt;a href=&quot;https://doc.rust-lang.org/nightly/unstable-book/language-features/unsized-locals.html&quot;&gt;unsized locals&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With this release, you can now use boxed functions in places that expect items implementing a function trait.&lt;/p&gt;
&lt;p&gt;The following code now works:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn foo(x: Box&amp;lt;dyn Fn(u8) -&amp;gt; u8&amp;gt;) -&amp;gt; Vec&amp;lt;u8&amp;gt; {
    vec![1, 2, 3, 4].into_iter().map(x).collect()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Furthermore, you can now directly call &lt;code&gt;Box&amp;lt;dyn FnOnce&amp;gt;&lt;/code&gt; objects:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn foo(x: Box&amp;lt;dyn FnOnce()&amp;gt;) {
    x()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href=&quot;#coercing-closures-to-unsafe-fn-pointers&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;coercing-closures-to-unsafe-fn-pointers&quot;&gt;&lt;/a&gt;Coercing closures to &lt;code&gt;unsafe fn&lt;/code&gt; pointers&lt;/h3&gt;
&lt;p&gt;Since &lt;a href=&quot;https://blog.rust-lang.org/2017/07/20/Rust-1.19.html&quot;&gt;Rust 1.19.0&lt;/a&gt;, it has been possible to coerce closures that do not capture from their environment into function pointers.
For example, you may write:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn twice(x: u8, f: fn(u8) -&amp;gt; u8) -&amp;gt; u8 {
    f(f(x))
}

fn main() {
    assert_eq!(42, twice(0, |x| x + 21));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This has however not extended to &lt;code&gt;unsafe&lt;/code&gt; function pointers.
With this release of Rust, you may now do so. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;/// The safety invariants are those of the `unsafe fn` pointer passed.
unsafe fn call_unsafe_fn_ptr(f: unsafe fn()) {
    f()
}

fn main() {
    // SAFETY: There are no invariants.
    // The closure is statically prevented from doing unsafe things.
    unsafe {
        call_unsafe_fn_ptr(|| {
            dbg!();
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href=&quot;#calling-dbg()-with-no-argument&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;calling-dbg()-with-no-argument&quot;&gt;&lt;/a&gt;Calling &lt;code&gt;dbg!()&lt;/code&gt; with no argument&lt;/h3&gt;
&lt;p&gt;For the benefit of all the occasional and frequent &amp;quot;print debuggers&amp;quot; out there,
&lt;a href=&quot;https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html#the-dbg-macro&quot;&gt;Rust 1.32.0&lt;/a&gt; saw the release of &lt;a href=&quot;https://doc.rust-lang.org/std/macro.dbg.html&quot;&gt;the &lt;code&gt;dbg!&lt;/code&gt; macro&lt;/a&gt;.
To recap, the macro allows you to quickly inspect the value of some expression with context.
For example, when running:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let mut x = 0;

    if dbg!(x == 1) {
        x += 1;
    }

    dbg!(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...you would see:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[src/main.rs:4] x == 1 = false
[src/main.rs:8] x = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As seen in the previous section, where the higher order function &lt;code&gt;call_unsafe_fn_ptr&lt;/code&gt; is called,
you may now also call &lt;code&gt;dbg!&lt;/code&gt; without passing any arguments.
This is useful when tracing what branches your application takes.
For example, with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let condition = true;

    if condition {
        dbg!();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...you would see:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[src/main.rs:5]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;In 1.35.0, a number of APIs have become stable.&lt;/p&gt;
&lt;p&gt;In addition, some implementations were added and other changes occured as well.
See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1350-2019-05-23&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#copy-the-sign-of-a-floating-point-number-onto-another&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;copy-the-sign-of-a-floating-point-number-onto-another&quot;&gt;&lt;/a&gt;Copy the sign of a floating point number onto another&lt;/h4&gt;
&lt;p&gt;With this release, new methods &lt;code&gt;copysign&lt;/code&gt; have been added to the floating point primitive types &lt;a href=&quot;https://doc.rust-lang.org/std/primitive.f32.html&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/primitive.f64.html&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.f32.html#method.copysign&quot;&gt;&lt;code&gt;f32::copysign&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.f64.html#method.copysign&quot;&gt;&lt;code&gt;f64::copysign&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As the name suggests, you can use these to copy the sign of one number onto another. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    assert_eq!(3.5_f32.copysign(-0.42), -3.5);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;a href=&quot;#check-whether-a-range-contains-a-value&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;check-whether-a-range-contains-a-value&quot;&gt;&lt;/a&gt;Check whether a &lt;code&gt;Range&lt;/code&gt; &lt;code&gt;contains&lt;/code&gt; a value&lt;/h4&gt;
&lt;p&gt;Rust 1.35.0 contains a few freshly minted methods on the &lt;code&gt;Range&lt;/code&gt; types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/ops/struct.Range.html#method.contains&quot;&gt;&lt;code&gt;Range::contains&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/ops/struct.RangeFrom.html#method.contains&quot;&gt;&lt;code&gt;RangeFrom::contains&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/ops/struct.RangeTo.html#method.contains&quot;&gt;&lt;code&gt;RangeTo::contains&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html#method.contains&quot;&gt;&lt;code&gt;RangeInclusive::contains&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/ops/struct.RangeToInclusive.html#method.contains&quot;&gt;&lt;code&gt;RangeToInclusive::contains&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With these, you can easily check whether a given value exists in a range. For example, you may write:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    if (0..=10).contains(&amp;amp;5) {
        println!(&amp;quot;Five is included in zero to ten.&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;a href=&quot;#map-and-split-a-borrowed-refcell-value-in-two&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;map-and-split-a-borrowed-refcell-value-in-two&quot;&gt;&lt;/a&gt;Map and split a borrowed &lt;code&gt;RefCell&lt;/code&gt; value in two&lt;/h4&gt;
&lt;p&gt;With Rust 1.35.0, you can now map and split the borrowed value of a &lt;code&gt;RefCell&lt;/code&gt; into multiple borrows for different components of the borrowed data:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/cell/struct.Ref.html#method.map_split&quot;&gt;&lt;code&gt;Ref::map_split&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/cell/struct.RefMut.html#method.map_split&quot;&gt;&lt;code&gt;RefMut::map_split&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;a href=&quot;#replace-the-value-of-a-refcell-through-a-closure&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;replace-the-value-of-a-refcell-through-a-closure&quot;&gt;&lt;/a&gt;Replace the value of a &lt;code&gt;RefCell&lt;/code&gt; through a closure&lt;/h4&gt;
&lt;p&gt;This release introduces a convenience method &lt;code&gt;replace_with&lt;/code&gt; on &lt;code&gt;RefCell&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.replace_with&quot;&gt;&lt;code&gt;RefCell::replace_with&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With it, you can more ergonomically map and replace the current value of the cell and get back the old value as a result.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#hash-a-pointer-or-reference-by-address-not-value&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;hash-a-pointer-or-reference-by-address-not-value&quot;&gt;&lt;/a&gt;Hash a pointer or reference by address, not value&lt;/h4&gt;
&lt;p&gt;In this release, we have introduced:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/ptr/fn.hash.html&quot;&gt;&lt;code&gt;ptr::hash&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This function takes a raw pointer and hashes it. Using &lt;code&gt;ptr::hash&lt;/code&gt;,
you can avoid hashing the pointed-to value of a reference and instead hash the address.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#copy-the-contents-of-an-option&amp;t&gt;&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;copy-the-contents-of-an-option&amp;t&gt;&quot;&gt;&lt;/a&gt;Copy the contents of an &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;From the very beginning with Rust 1.0.0,
the methods &lt;code&gt;Option::cloned&lt;/code&gt; for &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt; have allowed you to clone the contents in case of &lt;code&gt;Some(_)&lt;/code&gt;.
However, cloning can sometimes be an expensive operation and the methods &lt;code&gt;opt.cloned()&lt;/code&gt; provided no hints to that effect.&lt;/p&gt;
&lt;p&gt;With this release of Rust, we introduced:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/option/enum.Option.html#method.copied&quot;&gt;&lt;code&gt;Option::copied&lt;/code&gt;&lt;/a&gt; for both &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The functionality of &lt;code&gt;opt.copied()&lt;/code&gt; is the same as for &lt;code&gt;opt.cloned()&lt;/code&gt;.
However, calling the method requires that &lt;code&gt;T: Copy&lt;/code&gt;.
Using this method, you can make sure that code stops compiling should &lt;code&gt;T&lt;/code&gt; no longer implements &lt;code&gt;Copy&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#changes-in-clippy&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;changes-in-clippy&quot;&gt;&lt;/a&gt;Changes in Clippy&lt;/h3&gt;
&lt;p&gt;In this release of Rust,
Clippy (a collection of lints to catch common mistakes and improve your Rust code) added a new lint &lt;a href=&quot;https://rust-lang.github.io/rust-clippy/master/index.html#drop_bounds&quot;&gt;&lt;code&gt;drop_bounds&lt;/code&gt;&lt;/a&gt;.
This lint triggers when you add a bound &lt;code&gt;T: Drop&lt;/code&gt; to a generic function. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn foo&amp;lt;T: Drop&amp;gt;(x: T) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Having a bound &lt;code&gt;T: Drop&lt;/code&gt; is almost always a mistake as it excludes types,
such as &lt;code&gt;u8&lt;/code&gt;, which have trivial drop-glues.
Moreover, &lt;code&gt;T: Drop&lt;/code&gt; does not account for types like &lt;code&gt;String&lt;/code&gt; not having interesting destructor behavior directly but rather as a result of embedding types,
such as &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;, that do.&lt;/p&gt;
&lt;p&gt;In addition to &lt;a href=&quot;https://rust-lang.github.io/rust-clippy/master/index.html#drop_bounds&quot;&gt;&lt;code&gt;drop_bounds&lt;/code&gt;&lt;/a&gt;,
this release of Clippy &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/pull/4101&quot;&gt;split&lt;/a&gt; the lint&lt;code&gt;redundant_closure&lt;/code&gt; into &lt;code&gt;redundant_closure&lt;/code&gt; and &lt;code&gt;redundant_closure_for_method_calls&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-135-beta&quot;&gt;detailed release notes for Clippy&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#changes-in-cargo&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;changes-in-cargo&quot;&gt;&lt;/a&gt;Changes in Cargo&lt;/h3&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-135-2019-05-23&quot;&gt;detailed release notes for Cargo&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-135.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-135.0&quot;&gt;&lt;/a&gt;Contributors to 1.35.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.35.0.
We couldn't have done it without all of you.
&lt;a href=&quot;https://thanks.rust-lang.org/rust/1.35.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>The 2019 Rust Event Lineup</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/05/20/The-2019-Rust-Event-Lineup.html" type="text/html" title="The 2019 Rust Event Lineup" />
        <published>2019-05-20T00:00:00Z</published>
        <updated>2019-05-20T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/05/20/The-2019-Rust-Event-Lineup.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/05/20/The-2019-Rust-Event-Lineup.html">&lt;p&gt;We're excited for the 2019 conference season, which we're actually late in writing up. Some
incredible events have already happened! Read on to learn more about all the events occurring
around the world, past and future.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#december-15-16-2018:-rustrush&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;december-15-16-2018:-rustrush&quot;&gt;&lt;/a&gt;December 15-16, 2018: RustRush&lt;/h3&gt;
&lt;p&gt;Yes, &lt;a href=&quot;https://rustrush.ru/&quot;&gt;RustRush&lt;/a&gt; was actually in 2018, but we didn't cover it in the &lt;a href=&quot;https://blog.rust-lang.org/2018/01/31/The-2018-Rust-Event-Lineup.html&quot;&gt;2018 event
lineup&lt;/a&gt; so we're counting it in 2019! This was the first Rust event in Russia.
You can &lt;a href=&quot;https://www.youtube.com/playlist?list=PLTooeo4dmVkQ_1lHJEY99ZTH_oP5ksIUL&quot;&gt;watch the talk videos&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/rustrush1&quot;&gt;follow the conference on Twitter&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#march-29-30-2019:-rust-latam&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;march-29-30-2019:-rust-latam&quot;&gt;&lt;/a&gt;March 29-30, 2019: Rust Latam&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;https://rustlatam.org/&quot;&gt;Rust Latam Conference&lt;/a&gt; is Latin America's leading event about Rust. Their first
event happened in Montevideo this year, and &lt;a href=&quot;https://www.youtube.com/playlist?list=PL85XCvVPmGQjuWUNeFCgl8X2EOC_aAq5N&quot;&gt;the videos are available&lt;/a&gt; to watch!
Rust Latam plans to be a yearly event, so &lt;a href=&quot;https://twitter.com/RustLatamConf&quot;&gt;watch Twitter&lt;/a&gt; for information about next
year's event.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#april-20-23-2019:-rustcon-asia&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;april-20-23-2019:-rustcon-asia&quot;&gt;&lt;/a&gt;April 20-23, 2019: RustCon Asia&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://rustcon.asia/&quot;&gt;RustCon Asia&lt;/a&gt; was the first Rust conference in Asia! The &lt;a href=&quot;https://www.youtube.com/playlist?list=PL85XCvVPmGQjPvweRqkBgnh_HKE5MBB8x&quot;&gt;talk videos&lt;/a&gt; are already
available on YouTube! &lt;a href=&quot;https://twitter.com/RustConAsia&quot;&gt;Follow @RustConAsia&lt;/a&gt; on Twitter for future updates.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#april-26-29-2019:-oxidize&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;april-26-29-2019:-oxidize&quot;&gt;&lt;/a&gt;April 26-29, 2019: Oxidize&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://oxidizeconf.com/&quot;&gt;Oxidize&lt;/a&gt; was a conference specifically about using Rust on embedded devices that took
place in Berlin. Videos aren't out yet, but there'll probably be &lt;a href=&quot;https://twitter.com/OxidizeConf&quot;&gt;tweets&lt;/a&gt; when they are!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#june-28-29-2019:-rustlab&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;june-28-29-2019:-rustlab&quot;&gt;&lt;/a&gt;June 28-29, 2019: RustLab&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.rustlab.it/&quot;&gt;RustLab&lt;/a&gt; is a new conference for this year that will be taking place in Florence, Italy.
Their session and workshop lineup has been announced, and tickets are now available! &lt;a href=&quot;https://twitter.com/rustlab_conf&quot;&gt;Follow the
conference on Twitter&lt;/a&gt; for the most up-to-date information.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#august-22-23-rustconf&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;august-22-23-rustconf&quot;&gt;&lt;/a&gt;August 22-23: RustConf&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://rustconf.com/&quot;&gt;The official RustConf&lt;/a&gt; will again be taking place in Portland, OR, USA. Thursday is a
day of trainings and Friday is the main day of talks. See &lt;a href=&quot;https://twitter.com/rustconf&quot;&gt;Twitter&lt;/a&gt; for the latest
announcements!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#september-20-21-colorado-gold-rust&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;september-20-21-colorado-gold-rust&quot;&gt;&lt;/a&gt;September 20-21: Colorado Gold Rust&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://cogoldrust.com/&quot;&gt;Colorado Gold Rust&lt;/a&gt; is a new conference for this year, and is taking place in
Denver, CO, USA. Their CFP and ticket sales are open now, and you can also &lt;a href=&quot;https://twitter.com/COGoldRust&quot;&gt;follow them on
twitter&lt;/a&gt;!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#october-18-19-rust-belt-rust&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;october-18-19-rust-belt-rust&quot;&gt;&lt;/a&gt;October 18-19: Rust Belt Rust&lt;/h3&gt;
&lt;p&gt;This year's &lt;a href=&quot;https://www.rust-belt-rust.com/&quot;&gt;Rust Belt Rust&lt;/a&gt; will be taking place in Dayton, OH, USA, the birthplace of
flight! The CFP and ticket sales will open soon. Check &lt;a href=&quot;https://twitter.com/rustbeltrust&quot;&gt;Twitter&lt;/a&gt; for announcements.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#november-rustfest-barcelona&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;november-rustfest-barcelona&quot;&gt;&lt;/a&gt;November: RustFest Barcelona&lt;/h3&gt;
&lt;p&gt;The exact dates for &lt;a href=&quot;https://barcelona.rustfest.eu/&quot;&gt;RustFest Barcelona&lt;/a&gt; haven't been announced yet, but it's
slated to happen sometime in November. Keep an eye on the &lt;a href=&quot;https://twitter.com/rustfest&quot;&gt;RustFest Twitter&lt;/a&gt; for
announcements!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;We are so lucky and excited to have so many wonderful conferences around the world in 2019! Have
fun at the events, and we hope there are even more in 2020!&lt;/p&gt;
</content>

        <author>
            <name>Rust Community Team</name>
        </author>
    </entry>
    
    <entry>
        <title>4 years of Rust</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/05/15/4-Years-Of-Rust.html" type="text/html" title="4 years of Rust" />
        <published>2019-05-15T00:00:00Z</published>
        <updated>2019-05-15T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/05/15/4-Years-Of-Rust.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/05/15/4-Years-Of-Rust.html">&lt;p&gt;On May 15th, 2015, &lt;a href=&quot;https://blog.rust-lang.org/2015/05/15/Rust-1.0.html&quot;&gt;Rust&lt;/a&gt; was released to the world! After 5 years of open development (and a couple of years of sketching before that), we finally hit the button on making the attempt to create a new systems programming language a serious effort!&lt;/p&gt;
&lt;p&gt;It’s easy to look back on the pre-1.0 times and cherish them for being the wild times of language development and fun research. Features were added and cut, syntax and keywords were tried, and before 1.0, there was a big clean-up that removed a lot of the standard library. For fun, you can check Niko’s blog post on &lt;a href=&quot;https://smallcultfollowing.com/babysteps/blog/2012/04/09/rusts-object-system/&quot;&gt;how Rust's object system works&lt;/a&gt;, Marijn Haverbeke’s talk on &lt;a href=&quot;https://www.youtube.com/watch?v=olbTX95hdbg&quot;&gt;features that never made it close to 1.0&lt;/a&gt; or even the &lt;a href=&quot;http://venge.net/graydon/talks/intro-talk-2.pdf&quot;&gt;introductory slides about Servo&lt;/a&gt;, which present a language looking very different from today.&lt;/p&gt;
&lt;p&gt;Releasing Rust with stability guarantees also meant putting a stop to large visible changes. The face of Rust is still very similar to Rust 1.0. Even with the changes from last year’s 2018 Edition, Rust is still very recognizable as what it was in 2015. That steadiness hides that the time of Rust’s fastest development and growth is &lt;em&gt;now&lt;/em&gt;. With the stability of the language and easy upgrades as a base, a ton of new features have been built. We’ve seen a bunch of achievements in the last year:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We have been StackOverflow’s &lt;a href=&quot;https://insights.stackoverflow.com/survey/2019#most-loved-dreaded-and-wanted&quot;&gt;“Most loved programming language”&lt;/a&gt; 4 consecutive years in a row&lt;/li&gt;
&lt;li&gt;We opened up a whole new area of development for stable Rust: &lt;a href=&quot;https://www.rust-lang.org/what/embedded&quot;&gt;embedded development&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rust-lang.org/what/wasm&quot;&gt;Rust+WASM&lt;/a&gt; went from an experiment to a usable product, making rustc the first compiler with focus on supporting WASM&lt;/li&gt;
&lt;li&gt;We shipped a new language edition: &lt;a href=&quot;https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html&quot;&gt;Rust 2018&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://crates.io&quot;&gt;Crates.io&lt;/a&gt; passed a billion downloads and has over 25,000 crates available&lt;/li&gt;
&lt;li&gt;There’s now over 100 meetups around the world, in 42 countries&lt;/li&gt;
&lt;li&gt;6(!) new conferences were spun up (&lt;a href=&quot;https://rustrush.ru/&quot;&gt;RustRush&lt;/a&gt;, &lt;a href=&quot;https://rustcon.asia/&quot;&gt;RustCon Asia&lt;/a&gt;, &lt;a href=&quot;https://oxidizeconf.com/&quot;&gt;Oxidize&lt;/a&gt;, &lt;a href=&quot;https://rustlatam.org/&quot;&gt;Rust LATAM&lt;/a&gt;, &lt;a href=&quot;https://cogoldrust.com/&quot;&gt;Colorado Gold Rust&lt;/a&gt;, &lt;a href=&quot;https://www.rustlab.it/&quot;&gt;RustLab Italy&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This list could go on and on. While the time before and after release was a time where language changes had huge impact how Rust is perceived, it's becoming more and more important what people start building in and around it. This includes projects like whole game engines, but also many small, helpful libraries, meetup formats, tutorials other educational material. Birthdays are a great time to take a look back over the last year and see the happy parts!&lt;/p&gt;
&lt;p&gt;Rust would be nothing, and especially not winning prizes, without its community. Community happens everywhere! We would like to thank everyone for being along on this ride, from team members to small scale contributors to people just checking the language out and finding interest in it. Your interest and curiosity is what makes the Rust community an enjoyable place to be. Some meetups &lt;a href=&quot;https://calendar.google.com/calendar/embed?showTitle=0&amp;showPrint=0&amp;showTabs=0&amp;showCalendars=0&amp;mode=AGENDA&amp;height=400&amp;wkst=1&amp;bgcolor=%23FFFFFF&amp;src=apd9vmbc22egenmtu5l6c5jbfc%40group.calendar.google.com&amp;color=%23691426&amp;ctz=Europe%2FMadrid&quot;&gt;are running birthday parties&lt;/a&gt; today to which everyone is invited. If you are not attending one, you can take the chance to celebrate in any other fashion: maybe show us a picture of what you are currently working on or talk about what excites you. If you want to take it to social media, consider tagging our &lt;a href=&quot;https://twitter.com/rustlang&quot;&gt;Twitter account&lt;/a&gt; or using the hashtag #rustbirthday.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.34.2</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/05/14/Rust-1.34.2.html" type="text/html" title="Announcing Rust 1.34.2" />
        <published>2019-05-14T00:00:00Z</published>
        <updated>2019-05-14T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/05/14/Rust-1.34.2.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/05/14/Rust-1.34.2.html">&lt;p&gt;The Rust team has published a new point release of Rust, 1.34.2. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.34.2 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.34.2-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.34.2-stable&quot;&gt;&lt;/a&gt;What's in 1.34.2 stable&lt;/h2&gt;
&lt;p&gt;Sean McArthur reported a &lt;a href=&quot;https://groups.google.com/d/msg/rustlang-security-announcements/aZabeCMUv70/-2Y6-SL6AQAJ&quot;&gt;security vulnerability&lt;/a&gt; affecting the standard
library that caused the &lt;a href=&quot;https://doc.rust-lang.org/stable/std/error/trait.Error.html#method.downcast&quot;&gt;&lt;code&gt;Error::downcast&lt;/code&gt;&lt;/a&gt; family of methods
to perform unsound casts when a manual implementation of the
&lt;a href=&quot;https://doc.rust-lang.org/stable/std/error/trait.Error.html#method.type_id&quot;&gt;&lt;code&gt;Error::type_id&lt;/code&gt;&lt;/a&gt; method returned the wrong
&lt;a href=&quot;https://doc.rust-lang.org/stable/std/any/struct.TypeId.html&quot;&gt;&lt;code&gt;TypeId&lt;/code&gt;&lt;/a&gt;, leading to security issues such as out of bounds
reads/writes/etc.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/stable/std/error/trait.Error.html#method.type_id&quot;&gt;&lt;code&gt;Error::type_id&lt;/code&gt;&lt;/a&gt; method was recently stabilized as part
of Rust 1.34.0. This point release &lt;strong&gt;destabilizes&lt;/strong&gt; it, preventing any code on
the stable and beta channels to implement or use it, awaiting future plans that
will be discussed in &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60784&quot;&gt;issue #60784&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;An in-depth explaination of this issue was posted in yesterday's &lt;a href=&quot;https://groups.google.com/d/msg/rustlang-security-announcements/aZabeCMUv70/-2Y6-SL6AQAJ&quot;&gt;security
advisory&lt;/a&gt;. The assigned CVE for the vulnerability is &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12083&quot;&gt;CVE-2019-12083&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Security advisory for the standard library</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/05/13/Security-advisory.html" type="text/html" title="Security advisory for the standard library" />
        <published>2019-05-13T00:00:00Z</published>
        <updated>2019-05-13T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/05/13/Security-advisory.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/05/13/Security-advisory.html">&lt;p&gt;This is a cross-post of the &lt;a href=&quot;https://groups.google.com/forum/#!topic/rustlang-security-announcements/aZabeCMUv70&quot;&gt;official security advisory&lt;/a&gt;. The
official post contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;p&gt;The CVE for this vulnerability is &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12083&quot;&gt;CVE-2019-12083&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;The Rust team was recently notified of a security vulnerability affecting
manual implementations of &lt;code&gt;Error::type_id&lt;/code&gt; and their interaction with the
&lt;code&gt;Error::downcast&lt;/code&gt; family of functions in the standard library. If your code
does not manually implement &lt;code&gt;Error::type_id&lt;/code&gt; your code is not affected.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#overview&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Error::type_id&lt;/code&gt; function in the standard library was stabilized in the
1.34.0 release on 2019-04-11. This function allows acquiring the concrete
&lt;code&gt;TypeId&lt;/code&gt; for the underlying error type to downcast back to the original type.
This function has a default implementation in the standard library, but it can
also be overridden by downstream crates. For example, the following is
currently allowed on Rust 1.34.0 and Rust 1.34.1:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;struct MyType;

impl Error for MyType {
    fn type_id(&amp;amp;self) -&amp;gt; TypeId {
        // Enable safe casting to `String` by accident.
        TypeId::of::&amp;lt;String&amp;gt;()
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When combined with the &lt;code&gt;Error::downcast*&lt;/code&gt; family of methods this can enable
safe casting of a type to the wrong type, causing security issues such as out
of bounds reads/writes/etc.&lt;/p&gt;
&lt;p&gt;Prior to the 1.34.0 release this function was not stable and could not be
either implemented or called in stable Rust.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#affected-versions&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;affected-versions&quot;&gt;&lt;/a&gt;Affected Versions&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Error::type_id&lt;/code&gt; function was first stabilized in Rust 1.34.0, released on
2019-04-11. The Rust 1.34.1 release, published 2019-04-25, is also affected.
The &lt;code&gt;Error::type_id&lt;/code&gt; function has been present, unstable, for all releases of
Rust since 1.0.0 meaning code compiled with nightly may have been affected at
any time.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#mitigations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;Immediate mitigation of this bug requires removing manual implementations of
&lt;code&gt;Error::type_id&lt;/code&gt;, instead inheriting the default implementation which is
correct from a safety perspective. It is not the intention to have
&lt;code&gt;Error::type_id&lt;/code&gt; return &lt;code&gt;TypeId&lt;/code&gt; instances for other types.&lt;/p&gt;
&lt;p&gt;For long term mitigation we are going to destabilize this function. This is
unfortunately a breaking change for users calling &lt;code&gt;Error::type_id&lt;/code&gt; and for
users overriding &lt;code&gt;Error::type_id&lt;/code&gt;. For users overriding it's likely memory
unsafe, but users calling &lt;code&gt;Error::type_id&lt;/code&gt; have only been able to do so on
stable for a few weeks since the last 1.34.0 release, so it's thought that the
impact will not be too great to overcome.&lt;/p&gt;
&lt;p&gt;We will be releasing a 1.34.2 point release on 2019-05-14 (tomorrow) which
reverts &lt;a href=&quot;https://github.com/rust-lang/rust/pull/58048&quot;&gt;#58048&lt;/a&gt; and destabilizes the &lt;code&gt;Error::type_id&lt;/code&gt; function. The
upcoming 1.35.0 release along with the beta/nightly channels will also all be
updated with a destabilization.&lt;/p&gt;
&lt;p&gt;The final fate of the &lt;code&gt;Error::type_id&lt;/code&gt; API isn't decided upon just yet and is
the subject of &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60784&quot;&gt;#60784&lt;/a&gt;. No action beyond destabilization is currently
planned so nightly code may continue to exhibit this issue. We hope to fully
resolve this in the standard library soon.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#timeline-of-events&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;timeline-of-events&quot;&gt;&lt;/a&gt;Timeline of events&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Thu, May  9, 2019 at 14:07 PM - Bug reported to security@rust-lang.org&lt;/li&gt;
&lt;li&gt;Thu, May  9, 2019 at 15:10 PM - Alex reponds, confirming the bug&lt;/li&gt;
&lt;li&gt;Fri, May 10, 2019 - Plan for mitigation developed and implemented&lt;/li&gt;
&lt;li&gt;Mon, May 13, 2019 - PRs posted to GitHub for &lt;a href=&quot;https://github.com/rust-lang/rust/pull/60785&quot;&gt;stable&lt;/a&gt;/&lt;a href=&quot;https://github.com/rust-lang/rust/pull/60786&quot;&gt;beta&lt;/a&gt;/&lt;a href=&quot;https://github.com/rust-lang/rust/pull/60787&quot;&gt;master&lt;/a&gt; branches&lt;/li&gt;
&lt;li&gt;Mon, May 13, 2019 - Security list informed of this issue&lt;/li&gt;
&lt;li&gt;(planned) Tue, May 14, 2019 - Rust 1.34.2 is released with a fix for this issue&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#acknowledgements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;acknowledgements&quot;&gt;&lt;/a&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;Thanks to Sean McArthur, who found this bug and reported it to us in accordance
with our &lt;a href=&quot;https://www.rust-lang.org/policies/security&quot;&gt;security policy&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Mozilla IRC Sunset and the Rust Channel</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/04/26/Mozilla-IRC-Sunset-and-the-Rust-Channel.html" type="text/html" title="Mozilla IRC Sunset and the Rust Channel" />
        <published>2019-04-26T00:00:00Z</published>
        <updated>2019-04-26T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/04/26/Mozilla-IRC-Sunset-and-the-Rust-Channel.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/04/26/Mozilla-IRC-Sunset-and-the-Rust-Channel.html">&lt;p&gt;The Rust community has had a presence on Mozilla’s IRC network almost since Rust’s inception. Over time, the single channel grew into a set of pretty active channels where folks would come to ask Rust questions, coordinate work on Rust itself, and just in general chat about Rust.&lt;/p&gt;
&lt;p&gt;Mozilla &lt;a href=&quot;http://exple.tive.org/blarg/2019/04/26/synchronous-text/&quot;&gt;recently announced&lt;/a&gt; that it would be shutting down its IRC network, citing a growing maintenance and moderation burden. They are looking into new options for the Mozilla community, but this does leave the question open as to what the Rust project will do.&lt;/p&gt;
&lt;p&gt;Last year a lot of the teams &lt;a href=&quot;https://internals.rust-lang.org/t/exploring-new-communication-channels/7859&quot;&gt;started exploring new communication platforms&lt;/a&gt;. Almost all the Rust teams no longer use IRC as their official discussion platform, instead using Discord or Zulip (as well as a variety of video chat tools for synchronous meetings). The few teams that do use IRC are working with us to find a new home, likely a channel on Discord or Zulip.&lt;/p&gt;
&lt;p&gt;This leaves the #rust and #rust-beginners channels on Mozilla’s IRC network, which are still quite active, that will need a new home when Mozilla’s network shuts down. Rust’s &lt;a href=&quot;http://discord.gg/rust-lang&quot;&gt;official Discord server&lt;/a&gt; does have the #users, #help, and #beginners channels that fill in this purpose, and we recommend people start using those.&lt;/p&gt;
&lt;p&gt;We understand that not everyone wishes to switch to Discord for many reasons. For people who wish to continue using IRC, there is &lt;a href=&quot;http://webchat.freenode.net/?channels=##rust&quot;&gt;an unofficial freenode channel&lt;/a&gt; which you can hang out in, though we’d like to emphasize that this is not associated with the Rust teams and is not moderated by our Moderation team. You’re also free to create new channels on freenode &lt;a href=&quot;https://freenode.net/policies#off-topic-use&quot;&gt;in accordance with the freenode rules&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There are still a couple months before irc.mozilla.org shuts down — we’ll work at making this transition as smooth as possible in this time. Thanks to everyone who made #rust and #rust-beginners on Mozilla IRC a great place to hang out! We are sad to see it go. 😢&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.34.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/04/25/Rust-1.34.1.html" type="text/html" title="Announcing Rust 1.34.1" />
        <published>2019-04-25T00:00:00Z</published>
        <updated>2019-04-25T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/04/25/Rust-1.34.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/04/25/Rust-1.34.1.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.34.1, and a new version of rustup, 1.18.1.
Rust is a programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup,
getting Rust 1.34.1 and rustup 1.18.1 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.34.1-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.34.1-stable&quot;&gt;&lt;/a&gt;What's in 1.34.1 stable&lt;/h2&gt;
&lt;p&gt;This patch release fixes two false positives and &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/pull/3805&quot;&gt;a panic when checking macros&lt;/a&gt; in &lt;a href=&quot;https://github.com/rust-lang/rust-clippy&quot;&gt;Clippy&lt;/a&gt;.
Clippy is a tool which provides a collection of lints to catch common mistakes and improve your Rust code.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#false-positive-in-clippy:redundant_closure&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;false-positive-in-clippy:redundant_closure&quot;&gt;&lt;/a&gt;False positive in &lt;code&gt;clippy::redundant_closure&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;A false positive in the &lt;code&gt;redundant_closure&lt;/code&gt; lint was &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/pull/3821&quot;&gt;fixed&lt;/a&gt;.
The lint did not take into account &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/issues/3802&quot;&gt;differences in the number of borrows&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the following snippet, the method &lt;code&gt;required&lt;/code&gt; expects &lt;code&gt;dep: &amp;amp;D&lt;/code&gt; but the actual type of &lt;code&gt;dep&lt;/code&gt; is &lt;code&gt;&amp;amp;&amp;amp;D&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;dependencies.iter().filter(|dep| dep.required());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Clippy erronously suggested &lt;code&gt;.filter(Dependency::required)&lt;/code&gt;,
which is rejected by the compiler due to the difference in borrows.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#false-positive-in-clippy:missing_const_for_fn&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;false-positive-in-clippy:missing_const_for_fn&quot;&gt;&lt;/a&gt;False positive in &lt;code&gt;clippy::missing_const_for_fn&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Another false positive in the &lt;code&gt;missing_const_for_fn&lt;/code&gt; lint was &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/pull/3844&quot;&gt;fixed&lt;/a&gt;.
This lint did not take into account that functions inside &lt;code&gt;trait&lt;/code&gt; implementations cannot be &lt;code&gt;const fn&lt;/code&gt;s.
For example, when given the following snippet, the lint would trigger:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[derive(PartialEq, Eq)] // warning: this could be a const_fn
struct Point(isize, isize);

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&amp;gt; Self { // warning: this could be a const_fn
        Point(self.0 + other.0, self.1 + other.1)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-new-in-rustup-1.18.1&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-new-in-rustup-1.18.1&quot;&gt;&lt;/a&gt;What's new in rustup 1.18.1&lt;/h2&gt;
&lt;p&gt;A recent rustup release, 1.18.0, introduced &lt;a href=&quot;https://github.com/rust-lang/rustup.rs/issues/1794&quot;&gt;a regression&lt;/a&gt; that prevented installing Rust through the shell script on older platforms.
A patch was released that fixes the issue, avoiding to force TLS v1.2 on the platforms that don't support it.&lt;/p&gt;
&lt;p&gt;You can check out other rustup changes in its &lt;a href=&quot;https://github.com/rust-lang/rustup.rs/blob/master/CHANGELOG.md#1181---2019-04-25&quot;&gt;full release notes&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Rust's 2019 roadmap</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/04/23/roadmap.html" type="text/html" title="Rust's 2019 roadmap" />
        <published>2019-04-23T00:00:00Z</published>
        <updated>2019-04-23T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/04/23/roadmap.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/04/23/roadmap.html">&lt;p&gt;Each year the Rust community &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1728&quot;&gt;comes together&lt;/a&gt; to set out a
roadmap. This year, in addition to the &lt;a href=&quot;https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html&quot;&gt;survey&lt;/a&gt;, we put out a &lt;a href=&quot;https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html&quot;&gt;call for blog
posts&lt;/a&gt; in December, which resulted in &lt;a href=&quot;https://readrust.net/rust-2019/&quot;&gt;73 blog posts&lt;/a&gt;
written over the span of a few weeks. The end result is the recently-merged
&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md&quot;&gt;2019 roadmap RFC&lt;/a&gt;. To get all of the details, please give it a read,
but this post lays out some of the highlights.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#the-theme-maturity&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-theme-maturity&quot;&gt;&lt;/a&gt;The theme: Maturity&lt;/h1&gt;
&lt;p&gt;In short, 2019 will be a year of &lt;em&gt;rejuvenation&lt;/em&gt; and &lt;em&gt;maturation&lt;/em&gt; for the Rust
project. We shipped a lot of stuff last year, and grew a lot. Now it's time to
take a step back, take stock, and prepare for the future.&lt;/p&gt;
&lt;p&gt;The work we have planned for this year falls into three major categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Governance: improving how the project is run&lt;/li&gt;
&lt;li&gt;Finish long-standing requests: closing out work we've started but never finished&lt;/li&gt;
&lt;li&gt;Polish: improving the overall quality of the language and tooling&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#governance&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;governance&quot;&gt;&lt;/a&gt;Governance&lt;/h2&gt;
&lt;p&gt;Over the last three years, the Rust project has grown a lot. Rust used to have a core team of 8 members. When we added sub-teams in 2015, we grew to 23 members. We've now grown to over 100 — that's bigger than many companies! And of course, looking beyond the teams, the size of the Rust community as a whole has grown tremendously as well. As a result of this growth, we've found that the processes which served us well when we were a smaller project are starting to feel some strain.&lt;/p&gt;
&lt;p&gt;Many of the teams have announced plans to review and revamp their processes so as to scale better. Often this can be as simple as taking the time to write down things that previously were understood only informally — sometimes it means establishing new structures.&lt;/p&gt;
&lt;p&gt;Because of this widespread interest in governance, we've also created a new &lt;a href=&quot;https://internals.rust-lang.org/t/governance-working-group-announcement/9637&quot;&gt;&lt;strong&gt;Governance Working Group&lt;/strong&gt;&lt;/a&gt;. This group is going to be devoted to working with each team to hone its governance structure and to help pass lessons and strategies between teams.&lt;/p&gt;
&lt;p&gt;Additionally, the RFC process has been a great boon for Rust, but as we've grown, there have been times where it didn't work so well too.
We may look at revisions to the process this year.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#long-standing-requests&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;long-standing-requests&quot;&gt;&lt;/a&gt;Long-standing requests&lt;/h2&gt;
&lt;p&gt;There are a number of exciting initiatives that have been sitting in a limbo
state — the majority of the design is done, but there are some lingering
complications that we haven't had time to work out. This year we hope to take
a fresh look at some of these problems and try hard to resolve those
lingering problems.&lt;/p&gt;
&lt;p&gt;Examples include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Cargo team and custom registries&lt;/li&gt;
&lt;li&gt;The Language team is taking a look at async/await, specialization, const generics, and generic associated types&lt;/li&gt;
&lt;li&gt;The Libs team wants to finish custom allocators&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#polish&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;polish&quot;&gt;&lt;/a&gt;Polish&lt;/h2&gt;
&lt;p&gt;Finally, the last few years have also seen a lot of foundational work. The
compiler, for example, was massively refactored to support incremental
compilation and to be better prepared for IDEs. Now that we've got these
pieces in place, we want to do the “polish” work that really makes for a
great experience.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compile times and IDE support&lt;/li&gt;
&lt;li&gt;Polishing the specification of the language by improving &lt;a href=&quot;https://doc.rust-lang.org/stable/reference/&quot;&gt;the reference&lt;/a&gt; and laying out &lt;a href=&quot;https://github.com/rust-lang/unsafe-code-guidelines&quot;&gt;the unsafe code guidelines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The WebAssembly WG's work this year includes polishing our wasm support, for example, debugging&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#conclusion&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This post only covered a few examples of the plans we've been making. &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md&quot;&gt;If you'd like to see the full details, take a look at the RFC itself.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here's to a great 2019 for Rust!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.34.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html" type="text/html" title="Announcing Rust 1.34.0" />
        <published>2019-04-11T00:00:00Z</published>
        <updated>2019-04-11T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.34.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.34.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate
page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.34.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.34.0-stable&quot;&gt;&lt;/a&gt;What's in 1.34.0 stable&lt;/h2&gt;
&lt;p&gt;The largest feature in this release is the introduction of &lt;em&gt;alternative&lt;/em&gt; &lt;code&gt;cargo&lt;/code&gt; registries.
The release also includes support for &lt;code&gt;?&lt;/code&gt; in documentation tests,
some improvements for &lt;code&gt;#[attribute(..)]&lt;/code&gt;s, as well as the stabilization of &lt;code&gt;TryFrom&lt;/code&gt;.
Read on for a few highlights, or see the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1340-2019-04-11&quot;&gt;detailed release notes&lt;/a&gt; for additional information.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#alternative-cargo-registries&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;alternative-cargo-registries&quot;&gt;&lt;/a&gt;Alternative &lt;code&gt;cargo&lt;/code&gt; registries&lt;/h3&gt;
&lt;p&gt;Since before 1.0, Rust has had a public crate registry, &lt;a href=&quot;http://crates.io/&quot;&gt;crates.io&lt;/a&gt;.
People publish crates with &lt;code&gt;cargo publish&lt;/code&gt; and it's easy to include these crates
in the &lt;code&gt;[dependencies]&lt;/code&gt; section of your &lt;code&gt;Cargo.toml&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, not everyone &lt;em&gt;wants&lt;/em&gt; to publish their crates to crates.io.
People maintaining proprietary/closed-source code cannot use crates.io,
and instead are forced to use &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;path&lt;/code&gt; dependencies.
This is usually fine for small projects, but if you have a lot of closed-source crates
within a large organization, you lose the benefit of the versioning support that crates.io has.&lt;/p&gt;
&lt;p&gt;With this release, Cargo gains support for alternate registries.
These registries coexist with crates.io, so you can write software that depends
on crates from both crates.io and your custom registry.
Crates on crates.io cannot however depend on external registries.&lt;/p&gt;
&lt;p&gt;To use an alternate registry, you must add these lines to your &lt;code&gt;.cargo/config&lt;/code&gt;.
This file can be in your home directory (&lt;code&gt;~/.cargo/config&lt;/code&gt;) or relative to the package directory.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[registries]
my-registry = { index = &amp;quot;https://my-intranet:8080/git/index&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Depending on a crate from an alternate registry is easy.
When specifying dependencies in your &lt;code&gt;Cargo.toml&lt;/code&gt;, use the &lt;code&gt;registry&lt;/code&gt; key to
let Cargo know that you wish to fetch the crate from the alternate registry:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[dependencies]
other-crate = { version = &amp;quot;1.0&amp;quot;, registry = &amp;quot;my-registry&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a crate author, if you wish to publish your crate to an alternate registry,
you first need to save the authentication token into &lt;code&gt;~/.cargo/credentials&lt;/code&gt; with the &lt;code&gt;cargo login&lt;/code&gt; command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;cargo login --registry=my-registry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can then use the &lt;code&gt;--registry&lt;/code&gt; flag to indicate which registry to use when publishing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;cargo publish --registry=my-registry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is &lt;a href=&quot;https://doc.rust-lang.org/nightly/cargo/reference/registries.html#running-a-registry&quot;&gt;documentation&lt;/a&gt; on how to run your own registry.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#-in-documentation-tests&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;-in-documentation-tests&quot;&gt;&lt;/a&gt;&lt;code&gt;?&lt;/code&gt; in documentation tests&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://rust-lang.github.io/rfcs/1937-ques-in-main.html&quot;&gt;RFC 1937&lt;/a&gt; proposed adding support for using the &lt;code&gt;?&lt;/code&gt; operator in &lt;code&gt;fn main()&lt;/code&gt;,
&lt;code&gt;#[test]&lt;/code&gt; functions, and doctests, allowing them to return &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;,
with error values causing a nonzero exit code in the case of &lt;code&gt;fn main()&lt;/code&gt;,
and a test failure in the case of the tests.&lt;/p&gt;
&lt;p&gt;Support in &lt;code&gt;fn main()&lt;/code&gt; and &lt;code&gt;#[test]&lt;/code&gt; was implemented &lt;a href=&quot;https://blog.rust-lang.org/2018/05/10/Rust-1.26.html#main-can-return-a-result&quot;&gt;many releases ago&lt;/a&gt;.
However, the support within documentation tests was limited to doctests that have an explicit &lt;code&gt;fn main()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In this release, full support for &lt;code&gt;?&lt;/code&gt; in doctests has been added.
Now, you can write this in your documentation tests:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;/// ```rust
/// use std::io;
/// let mut input = String::new();
/// io::stdin().read_line(&amp;amp;mut input)?;
/// # Ok::&amp;lt;(), io::Error&amp;gt;(())
/// ```
fn my_func() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You still have to specify the error type being used at the bottom of the documentation test.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#custom-attributes-accept-arbitrary-token-streams&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;custom-attributes-accept-arbitrary-token-streams&quot;&gt;&lt;/a&gt;Custom attributes accept arbitrary token streams&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html&quot;&gt;Procedural macros&lt;/a&gt; in Rust can define custom attributes that they consume.
Until now, such attributes were restricted to being trees of paths and literals
according to a specific syntax, like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[foo(bar)]
#[foo = &amp;quot;bar&amp;quot;]
#[foo = 0]
#[foo(bar = true)]
#[foo(bar, baz(quux, foo = &amp;quot;bar&amp;quot;))]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unlike procedural macros, these helper attributes could not accept arbitrary token streams in delimiters,
so you could not write &lt;code&gt;#[range(0..10)]&lt;/code&gt; or &lt;code&gt;#[bound(T: MyTrait)]&lt;/code&gt;.
Procedural macro crates would instead use strings for specifying syntaxes like this, e.g. &lt;code&gt;#[range(&amp;quot;0..10&amp;quot;)]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;With this Rust release, custom attributes &lt;code&gt;#[attr($tokens)]&lt;/code&gt; &lt;a href=&quot;https://github.com/rust-lang/rust/pull/57367&quot;&gt;now accept&lt;/a&gt;
arbitrary token streams in &lt;code&gt;$tokens&lt;/code&gt;, bringing them on par with macros.
If you're the author of a procedural macro crate, please check if your custom attributes
have unnecessary strings in their syntax and if they can be better expressed with token streams.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#tryfrom-and-tryinto&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;tryfrom-and-tryinto&quot;&gt;&lt;/a&gt;&lt;code&gt;TryFrom&lt;/code&gt; and &lt;code&gt;TryInto&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/std/convert/trait.TryFrom.html&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/convert/trait.TryInto.html&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; traits were stabilized to allow fallible type conversions.&lt;/p&gt;
&lt;p&gt;For example, the &lt;a href=&quot;https://doc.rust-lang.org/std/primitive.u32.html#method.from_be_bytes&quot;&gt;&lt;code&gt;from_be_bytes&lt;/code&gt;&lt;/a&gt; and related methods on integer types take arrays,
but data is often read in via slices. Converting between slices and arrays is tedious to do manually.
With the new traits, it can be done inline with &lt;code&gt;.try_into()&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let num = u32::from_be_bytes(slice.try_into()?);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For conversions that cannot fail, such as &lt;code&gt;u8&lt;/code&gt; to &lt;code&gt;u32&lt;/code&gt;, the &lt;a href=&quot;https://doc.rust-lang.org/std/convert/enum.Infallible.html&quot;&gt;&lt;code&gt;Infallible&lt;/code&gt;&lt;/a&gt; type was added.
This also permits a blanket implementation of &lt;code&gt;TryFrom&lt;/code&gt; for all existing &lt;code&gt;From&lt;/code&gt; implementations.
In the future, we hope to turn &lt;code&gt;Infallible&lt;/code&gt; into an alias for &lt;a href=&quot;https://github.com/rust-lang/rust/issues/35121&quot;&gt;the &lt;code&gt;!&lt;/code&gt; (never) type&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#fn-before_exec-deprecated-in-favor-of-unsafe-fn-pre_exec&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;fn-before_exec-deprecated-in-favor-of-unsafe-fn-pre_exec&quot;&gt;&lt;/a&gt;&lt;code&gt;fn before_exec&lt;/code&gt; deprecated in favor of &lt;code&gt;unsafe fn pre_exec&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;On Unix-like systems, the function &lt;a href=&quot;https://doc.rust-lang.org/std/os/unix/process/trait.CommandExt.html#tymethod.before_exec&quot;&gt;&lt;code&gt;CommandExt::before_exec&lt;/code&gt;&lt;/a&gt; allows you to
schedule a closure to be run before &lt;code&gt;exec&lt;/code&gt; is invoked.&lt;/p&gt;
&lt;p&gt;The closure provided will be run in the context of the child process after a fork.
This means that resources, such as file descriptors and memory-mapped regions, may get duplicated.
In other words, you can now copy a value of a non-&lt;code&gt;Copy&lt;/code&gt; type into a different process
while retaining the original in the parent. This makes &lt;a href=&quot;https://github.com/rust-lang/rust/issues/39575#issuecomment-437658766&quot;&gt;it possible&lt;/a&gt; to cause
undefined behavior and break &lt;a href=&quot;https://github.com/rust-lang/rust/issues/39575#issuecomment-439645949&quot;&gt;libraries assuming non-duplication&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;before_exec&lt;/code&gt; should therefore have been marked as &lt;code&gt;unsafe&lt;/code&gt;.
In this release of Rust, we have deprecated &lt;code&gt;fn before_exec&lt;/code&gt; in favor of the &lt;code&gt;unsafe fn pre_exec&lt;/code&gt;.
When calling &lt;a href=&quot;https://doc.rust-lang.org/std/os/unix/process/trait.CommandExt.html#tymethod.pre_exec&quot;&gt;&lt;code&gt;CommandExt::pre_exec&lt;/code&gt;&lt;/a&gt;, it is your responsibility to make sure that the closure
does not violate library invariants by making invalid use of these duplicates.
If you provide a library that is in a similar situation as &lt;code&gt;before_exec&lt;/code&gt;,
consider deprecating and providing an &lt;code&gt;unsafe&lt;/code&gt; alternative as well.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;In 1.34.0, the set of stable atomic integer types was expanded,
with signed and unsigned variants from 8 (&lt;a href=&quot;https://doc.rust-lang.org/std/sync/atomic/struct.AtomicU8.html&quot;&gt;&lt;code&gt;AtomicU8&lt;/code&gt;&lt;/a&gt;) to 64 bits now available.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1280-2018-08-02&quot;&gt;Previously&lt;/a&gt;, non-zero unsigned integer types, e.g. &lt;a href=&quot;https://doc.rust-lang.org/std/num/struct.NonZeroU8.html&quot;&gt;&lt;code&gt;NonZeroU8&lt;/code&gt;&lt;/a&gt;, were stabilized.
This gave &lt;code&gt;Option&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt; the same size as &lt;code&gt;u8&lt;/code&gt;.
With this Rust release, signed versions, e.g. &lt;a href=&quot;https://doc.rust-lang.org/std/num/struct.NonZeroI8.html&quot;&gt;&lt;code&gt;NonZeroI8&lt;/code&gt;&lt;/a&gt;, have been stabilized.&lt;/p&gt;
&lt;p&gt;The functions &lt;a href=&quot;https://doc.rust-lang.org/std/iter/fn.from_fn.html&quot;&gt;&lt;code&gt;iter::from_fn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/iter/fn.successors.html&quot;&gt;&lt;code&gt;iter::successors&lt;/code&gt;&lt;/a&gt; have been stabilized.
The former allows you to construct an iterator from &lt;code&gt;FnMut() -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt;.
To pop elements from a vector iteratively, you can now write &lt;code&gt;from_fn(|| vec.pop())&lt;/code&gt;.
Meanwhile, the latter creates a new iterator where each successive item
is computed based on the preceding one.&lt;/p&gt;
&lt;p&gt;Additionally, these APIs have become stable:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/any/trait.Any.html#tymethod.type_id&quot;&gt;Any::type_id&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/error/trait.Error.html#method.type_id&quot;&gt;Error::type_id&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.sort_by_cached_key&quot;&gt;slice::sort_by_cached_key&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.escape_debug&quot;&gt;str::escape_debug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.escape_default&quot;&gt;str::escape_default&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.escape_unicode&quot;&gt;str::escape_unicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.split_ascii_whitespace&quot;&gt;str::split_ascii_whitespace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Instant.html#method.checked_add&quot;&gt;Instant::checked_add&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Instant.html#method.checked_sub&quot;&gt;Instant::checked_sub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.SystemTime.html#method.checked_add&quot;&gt;SystemTime::checked_add&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.SystemTime.html#method.checked_sub&quot;&gt;SystemTime::checked_sub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1340-2019-04-11&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.33.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html" type="text/html" title="Announcing Rust 1.33.0" />
        <published>2019-02-28T00:00:00Z</published>
        <updated>2019-02-28T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.33.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.33.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes for
1.33.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.33.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.33.0-stable&quot;&gt;&lt;/a&gt;What's in 1.33.0 stable&lt;/h2&gt;
&lt;p&gt;The two largest features in this release are significant improvements to
&lt;code&gt;const fn&lt;/code&gt;s, and the stabilization of a new concept: &amp;quot;pinning.&amp;quot;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#const-fn-improvements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;const-fn-improvements&quot;&gt;&lt;/a&gt;&lt;code&gt;const fn&lt;/code&gt; improvements&lt;/h3&gt;
&lt;p&gt;With &lt;code&gt;const fn&lt;/code&gt;, you can &lt;a href=&quot;https://github.com/rust-lang/rust/pull/57175/&quot;&gt;now do way more
things!&lt;/a&gt; Specifically:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;irrefutable destructuring patterns (e.g. &lt;code&gt;const fn foo((x, y): (u8, u8)) { ... }&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let&lt;/code&gt; bindings (e.g. &lt;code&gt;let x = 1;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;mutable &lt;code&gt;let&lt;/code&gt; bindings (e.g. &lt;code&gt;let mut x = 1;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;assignment (e.g. &lt;code&gt;x = y&lt;/code&gt;) and assignment operator (e.g. &lt;code&gt;x += y&lt;/code&gt;)
expressions, even where the assignment target is a projection (e.g. a struct
field or index operation like &lt;code&gt;x[3] = 42&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;expression statements (e.g. &lt;code&gt;3;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You're also &lt;a href=&quot;https://github.com/rust-lang/rust/pull/57067/&quot;&gt;able to call &lt;code&gt;const unsafe fn&lt;/code&gt;s inside a &lt;code&gt;const fn&lt;/code&gt;&lt;/a&gt;, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const unsafe fn foo() -&amp;gt; i32 { 5 }
const fn bar() -&amp;gt; i32 {
    unsafe { foo() }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With these additions, many more functions in the standard library are able to
be marked as &lt;code&gt;const&lt;/code&gt;. We'll enumerate those in the library section below.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#pinning&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;pinning&quot;&gt;&lt;/a&gt;Pinning&lt;/h3&gt;
&lt;p&gt;This release introduces a new concept for Rust programs, implemented as two
types: the &lt;a href=&quot;https://doc.rust-lang.org/std/pin/struct.Pin.html&quot;&gt;&lt;code&gt;std::pin::Pin&amp;lt;P&amp;gt;&lt;/code&gt;
type&lt;/a&gt;, and the &lt;a href=&quot;https://doc.rust-lang.org/std/marker/trait.Unpin.html&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;
marker trait&lt;/a&gt;. The core
idea is elaborated on in &lt;a href=&quot;https://doc.rust-lang.org/std/pin/index.html&quot;&gt;the docs for
&lt;code&gt;std::pin&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is sometimes useful to have objects that are guaranteed to not move, in
the sense that their placement in memory does not change, and can thus be
relied upon. A prime example of such a scenario would be building
self-referential structs, since moving an object with pointers to itself will
invalidate them, which could cause undefined behavior.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; ensures that the pointee of any pointer type &lt;code&gt;P&lt;/code&gt; has a stable location
in memory, meaning it cannot be moved elsewhere and its memory cannot be
deallocated until it gets dropped. We say that the pointee is &amp;quot;pinned&amp;quot;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This feature will largely be used by library authors, and so we won't talk a
lot more about the details here. Consult the docs if you're interested in
digging into the details. However, the stabilization of this API is important
to Rust users generally because it is a significant step forward towards a
highly anticipated Rust feature: &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;. We're not quite there yet,
but this stabilization brings us one step closer. You can track all of the
necessary features at &lt;a href=&quot;https://areweasyncyet.rs/&quot;&gt;areweasyncyet.rs&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#import-as-_&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;import-as-_&quot;&gt;&lt;/a&gt;Import as &lt;code&gt;_&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56303/&quot;&gt;You can now import an item as
&lt;code&gt;_&lt;/code&gt;&lt;/a&gt;. This allows you to
import a trait's impls, and not have the name in the namespace. e.g.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::io::Read as _;

// Allowed as there is only one `Read` in the module.
pub trait Read {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;Here's all of the stuff that's been made &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57566&quot;&gt;The methods &lt;code&gt;overflowing_{add, sub, mul, shl, shr}&lt;/code&gt; are now &lt;code&gt;const&lt;/code&gt;
functions for all numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57105&quot;&gt;The methods &lt;code&gt;rotate_left&lt;/code&gt;, &lt;code&gt;rotate_right&lt;/code&gt;, and &lt;code&gt;wrapping_{add, sub, mul, shl, shr}&lt;/code&gt;
are now &lt;code&gt;const&lt;/code&gt; functions for all numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57105&quot;&gt;The methods &lt;code&gt;is_positive&lt;/code&gt; and &lt;code&gt;is_negative&lt;/code&gt; are now &lt;code&gt;const&lt;/code&gt; functions for
all signed numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57167&quot;&gt;The &lt;code&gt;get&lt;/code&gt; method for all &lt;code&gt;NonZero&lt;/code&gt; types is now &lt;code&gt;const&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57234&quot;&gt;The methods &lt;code&gt;count_ones&lt;/code&gt;, &lt;code&gt;count_zeros&lt;/code&gt;, &lt;code&gt;leading_zeros&lt;/code&gt;, &lt;code&gt;trailing_zeros&lt;/code&gt;,
&lt;code&gt;swap_bytes&lt;/code&gt;, &lt;code&gt;from_be&lt;/code&gt;, &lt;code&gt;from_le&lt;/code&gt;, &lt;code&gt;to_be&lt;/code&gt;, &lt;code&gt;to_le&lt;/code&gt; are now &lt;code&gt;const&lt;/code&gt; for all
numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57234&quot;&gt;&lt;code&gt;Ipv4Addr::new&lt;/code&gt; is now a &lt;code&gt;const&lt;/code&gt; function&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, these APIs have become stable:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.read_exact_at&quot;&gt;&lt;code&gt;unix::FileExt::read_exact_at&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.write_all_at&quot;&gt;&lt;code&gt;unix::FileExt::write_all_at&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/option/enum.Option.html#method.transpose&quot;&gt;&lt;code&gt;Option::transpose&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose&quot;&gt;&lt;code&gt;Result::transpose&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/convert/fn.identity.html&quot;&gt;&lt;code&gt;convert::identity&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/pin/struct.Pin.html&quot;&gt;&lt;code&gt;pin::Pin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/marker/trait.Unpin.html&quot;&gt;&lt;code&gt;marker::Unpin&lt;/code&gt;&lt;/a&gt; (mentioned above)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/marker/struct.PhantomPinned.html&quot;&gt;&lt;code&gt;marker::PhantomPinned&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/vec/struct.Vec.html#method.resize_with&quot;&gt;&lt;code&gt;Vec::resize_with&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.resize_with&quot;&gt;&lt;code&gt;VecDeque::resize_with&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_millis&quot;&gt;&lt;code&gt;Duration::as_millis&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_micros&quot;&gt;&lt;code&gt;Duration::as_micros&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_nanos&quot;&gt;&lt;code&gt;Duration::as_nanos&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cargo-features&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cargo-features&quot;&gt;&lt;/a&gt;Cargo features&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/cargo/pull/6484/&quot;&gt;Cargo should now rebuild a crate if a file was modified during the initial
build.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cratesio&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cratesio&quot;&gt;&lt;/a&gt;Crates.io&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://users.rust-lang.org/t/a-verified-email-address-will-be-required-to-publish-to-crates-io-starting-on-2019-02-28/22425&quot;&gt;As previously announced&lt;/a&gt;, coinciding with this release, crates.io
will require that you have a verified email address to publish. Starting at
2019-03-01 00:00 UTC, if you don't have a verified email address and run &lt;code&gt;cargo publish&lt;/code&gt;, you'll get an error.&lt;/p&gt;
&lt;p&gt;This ensures we can comply with DMCA procedures. If you haven't heeded the
warnings cargo printed during the last release cycle, head on over to
&lt;a href=&quot;https://crates.io/me&quot;&gt;crates.io/me&lt;/a&gt; to set and verify your email address. This email address
will never be displayed publicly and will only be used for crates.io operations.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-133.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-133.0&quot;&gt;&lt;/a&gt;Contributors to 1.33.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.33.0. We couldn't have done it
without all of you. &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.33.0&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
</feed>